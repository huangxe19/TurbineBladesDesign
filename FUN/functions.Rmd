---
title: "Functions"
author: "Xige Huang"
date: '2022-04-15'
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(dplyr)
library(R.matlab)
library(plgp)
library(ggplot2)
library(lhs)
library(laGP)
library(readr)
library(maximin)
```

# Generate Beta Distribution Design
```{r}
BetaDistD <- function(n, m=2, a = 2,b = 5, T=100000) {  
  X <- matrix(runif(n*m), ncol=m)    
  D_init <- distance(X)
  D_init <- D_init[upper.tri(D_init)]
  KSD <- ks.test(D_init,"pbeta",a,b)$statistic

  for(t in 1:T) {
    row <- sample(1:n, 1)             
    Xold <- X                         
    X[row,] <- runif(m)             
    D_s <- distance(X)
    D_s <- D_s[upper.tri(D_s)]
    KSDprime <- ks.test(D_s,"pbeta",a,b)$statistic
    if(KSDprime < KSD) { KSD <- KSDprime 
    } else { X <- Xold }              
  }

  return(X)
}
```


# convert design to actual scale

```{r}
convert_scale <- function(OldMax=1, OldMin=0, OldValue, NewMax, NewMin){
  OldRange = (OldMax - OldMin)  
  NewRange = (NewMax - NewMin)  
  NewValue = (((OldValue - OldMin) * NewRange) / OldRange) + NewMin
}
convert_vars <- function(oldmatrix){
  young <- mapply(convert_scale, OldValue = oldmatrix[,1], NewMax = 300e9, NewMin=200e9)
  poisson <- mapply(convert_scale, OldValue = oldmatrix[,2], NewMax = 0.1, NewMin=0.49)
  CTE <- mapply(convert_scale, OldValue = oldmatrix[,3], NewMax = 5e-6, NewMin=1.5e-5)
  thermal <- mapply(convert_scale, OldValue = oldmatrix[,4], NewMax = 5, NewMin=15)
  temp <- mapply(convert_scale, OldValue = oldmatrix[,5], NewMax = 50, NewMin=360)
  pressure <- mapply(convert_scale, OldValue = oldmatrix[,6], NewMax = 1e5, NewMin=4.8e5)
  newmatrix <- matrix(c(young, poisson, CTE, thermal, temp, pressure),
                      byrow=F, ncol=6)
return(newmatrix)
}
```

```{r}
#oldmatrix <- matrix(runif(n=4*6), ncol=6)
#test1 <- convert_vars(oldmatrix)
```

# interface between R and Matlab
```{r}
options(matlab="/Applications/MATLAB_R2022a.app/bin/matlab")
Matlab$startServer()
matlab <- Matlab()
isOpen <- open(matlab)
print(matlab)
```

```{r}
simulator <- function(input){
  ymod = input[1]; prat = input[2]; cte = input[3]; 
  therm = input[4]; input[5]; input[6]
  
  # set a variable in R and send to MATLB
  setVariable(matlab,
              ymod = ymod,
              prat = prat,
              cte = cte,
              therm = therm,
              ctemp = ctemp,
              press = press)
  
  evaluate(matlab, "[stress,displ] = simulator(ymod,prat,cte,therm,ctemp,press)")
  
  return(c(getVariable(matlab, "stress")$stress,getVariable(matlab, "displ")$displ))
}
```


```{r}
close(matlab)
```



# ALC function

```{r}
obj.alc <- function(x, gpi, Xref){
  return(- sqrt(alcGP(gpi, matrix(x, nrow=1), Xref)))
}
```

```{r}
xnp1.search <- function(X, gpi, obj=obj.alm, ...)
{
start <- mymaximin(nrow(X), 2, T=100*nrow(X), Xorig=X)
xnew <- matrix(NA, nrow=nrow(start), ncol=ncol(X) + 1)
for(i in 1:nrow(start)) {
out <- optim(start[i,], obj, method="L-BFGS-B", lower=0,
upper=1, gpi=gpi, ...)
xnew[i,] <- c(out$par, -out$value)
}
solns <- data.frame(cbind(start, xnew))
names(solns) <- c("s1", "s2", "x1", "x2", "val")
return(solns)
}
```



```{r}
ALC <- function(ninit = 12, num_para = 2, method = randomLHS, niter, f,){
  
  # need to change f to simulator
  
  X <- method(ninit, num_para)
  y <- f(X)
  
  x1 <- x2 <- seq(0, 1, length=niter)
  XX <- expand.grid(x1, x2)
  yytrue <- f(XX, sd=0)
  
  g <- garg(list(mle=TRUE, max=1), y)
  d <- darg(list(mle=TRUE, max=0.25), X)
  gpi <- newGP(X, y, d=d$start, g=g$start, dK=TRUE)
  mle <- jmleGP(gpi, c(d$min, d$max), c(g$min, g$max), d$ab, g$ab)
  p <- predGP(gpi, XX, lite=TRUE)
  rmse.alc <- sqrt(mean((yytrue - p$mean)^2))
  
  
  Xref <- method(niter, num_para)
  solns <- xnp1.search(X, gpi, obj=obj.alc, Xref=Xref)
  m <- which.max(solns$val)
  xnew <- as.matrix(solns[m, 3:4])
  prog.alc <- solns$val[m]
  
  X <- rbind(X, xnew)
  y <- c(y, f(xnew))
  updateGP(gpi, xnew, y[length(y)])
  mle <- rbind(mle, jmleGP(gpi, c(d$min, d$max), c(g$min, g$max),
  d$ab, g$ab))
  p <- predGP(gpi, XX, lite=TRUE)
  rmse.alc <- c(rmse.alc, sqrt(mean((yytrue - p$mean)^2)))
  
  d <- darg(list(mle=TRUE), X)
  for(i in nrow(X):(niter-1)) {
    Xref <- randomLHS(niter, num_para)
    solns <- xnp1.search(X, gpi, obj=obj.alc, Xref=Xref)
    m <- which.max(solns$val)
    prog.alc <- c(prog.alc, solns$val[m])
    xnew <- as.matrix(solns[m, 3:4])
    X <- rbind(X, xnew)
    y <- c(y, f(xnew))
    updateGP(gpi, xnew, y[length(y)])
    mle <- rbind(mle, jmleGP(gpi, c(d$min, d$max), c(g$min, g$max),
    d$ab, g$ab))
    p <- predGP(gpi, XX, lite=TRUE)
    rmse.alc <- c(rmse.alc, sqrt(mean((yytrue - p$mean)^2)))
  }
  
  return(list(X = X, y = y, rmse.alc = rmse.alc))
}
```


```{r}
res = ALC(niter = 100)
```


# EI

```{r}
# objective
obj.EI <- function(x, fmin, gpi, pred=predGPsep)
- EI(gpi, x, fmin, pred)
```

```{r}
eps <- sqrt(.Machine$double.eps) ## used lots below
EI.search <- function(X, y, gpi, pred=predGPsep, multi.start=5, tol=eps)
  {
  m <- which.min(y)
  fmin <- y[m]
  start <- matrix(X[m,], nrow=1)
  if(multi.start > 1)
  start <- rbind(start, randomLHS(multi.start - 1, ncol(X)))
  xnew <- matrix(NA, nrow=nrow(start), ncol=ncol(X)+1)
  for(i in 1:nrow(start)) {
    if(EI(gpi, start[i,], fmin) <= tol) { out <- list(value=-Inf); next }
    out <- optim(start[i,], obj.EI, method="L-BFGS-B",
    lower=0, upper=1, gpi=gpi, pred=pred, fmin=fmin)
    xnew[i,] <- c(out$par, -out$value)
  }
  solns <- data.frame(cbind(start, xnew))
  names(solns) <- c("s1", "s2", "x1", "x2", "val")
  solns <- solns[solns$val > tol,]
  return(solns)
  }
```

```{r}
optim.EI <- function(f, X_init, Y_init, end)
{
  X <- X_init
  y <- Y_init
  gpi <- newGPsep(X, y, d=0.1, g=1e-6, dK=TRUE)
  da <- darg(list(mle=TRUE, max=0.5), randomLHS(1000, 2))
  mleGPsep(gpi, param="d", tmin=da$min, tmax=da$max, ab=da$ab)
  ## optimization loop of sequential acquisitions
  maxei <- c()
  ninit <- nrow(X_init)
  for(i in (ninit+1):end) {
    solns <- EI.search(X, y, gpi)
    m <- which.max(solns$val)
    maxei <- c(maxei, solns$val[m])
    xnew <- as.matrix(solns[m,3:4])
    ynew <- f(xnew)
    updateGPsep(gpi, xnew, ynew)
    mleGPsep(gpi, param="d", tmin=da$min, tmax=da$max, ab=da$ab)
    X <- rbind(X, xnew)
    y <- c(y, ynew)
  }
  ## clean up and return
  deleteGPsep(gpi)
  return(list(X=X, y=y, maxei=maxei))
  }
```

```{r}
os <- optim.EI(f, X_init, Y_init, end)
```


